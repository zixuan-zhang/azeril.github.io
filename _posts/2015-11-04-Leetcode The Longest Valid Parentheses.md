---
layout: post
title: LeetCode: The Longest Valid Parentheses
categories: [LeetCode,算法]
tags: [LeetCode,算法]
description: "Blog of Thought"
---

### 题目
> Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid(well-formed) parentheses substring.
For “(()”, the longest valid parentheses substring is “()”, which has length=2.
> Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4

### 翻译
给一个只包含 ‘(‘ 和 ‘)’两个字符的字符串，找到最长有合法的括号对。并把长度求出来。

### 分析
首先一个问题，什么样的字符串括号对才是合法的？先看几个例子：

* “(”        NO
* “((”       NO
* “()”      Yes
* “()(”     NO
* “())”     NO

从上面的例子来看，合法的括号对必须包含偶数个字符，且左括号和右括号的数量是一样的。再看一组例子：
* “)(”      NO
* “()”      YES

所以，还要满足， 以任意字符处结尾，都必须满足左括号的数量大于等于右括号的数量。因此，合法的字符应该满足以下条件：
1. 字符串必须包含偶数个字符
2. 左括号和右括号的数量相同
3. 以任意字符处结尾的子字符串中，左括号的数量大于等于右括号的数量。这个条件很重要。

### 解法一 暴力法：

分析到这，很容易就想到可以用暴力法。切割子串，然后判断这个子串是不是合法的括号对。切割子串的时间复杂度是O(n^2)，判断子串是否是合法的需要O(n)，因此此方法的时间复杂度是O(n^3)。然后可以在此基础上进行优化：优先切割较长的字符串，子串长度由n到2，然后判断子串是否是合法的，如果是合法的，就不用继续切割了。这种优化方法可以在一定程度上提高效率，但是时间复杂度在理论上没有变化。

### 解法二 动态规划
有没有更好的方法呢？看到最长合法括号对，很容易想到可不可以用动态规划的方法去做这道题。这里不详细介绍动态规划的思想，如果对动态规划不了解，可以先仔细读一下动态规划：从新手到专家。**动态规划算法通常是基于一个递推公式及一个或多个初始状态，当前子问题的解将由上次子问题的解推出。** 那，在这个问题中，这个状态应该是什么呢？我们可以在用一个例子进行分析。当没有思路的时候，最好的方法就是用一个实例来探索一下。我们看这个字符串。
* “()(()”

我们从字符串的begin到end进行遍历，首先第一个字符'(‘，此时肯定不是合法的，再遍历第二个字符’)’，诶，此时从开始到第二个字符是一个合法的括号对了。所以，我们还可以推出一个结论：**合法的括号对都是以’)’结尾的。** 并且此时，左括号的数量和右括号的数量一样。我们怎么知道左括号和右括号的数量一样呢？我们可以用一个数组left[]来标记。left[i]的意思是说以第i个字符结尾的子串的剩余左括号的数量。在这个例子中left[1]=1，因为只有一个'(‘，left[2]=1，左括号和右括号抵消了。

好，回到动态规划的核心问题，状态是什么？其实，很容易想到，**F(i)可以是第i个字符结尾的最大合法括号对的对数**（不是长度，是长度的一般）。到了这里，我们已经迈出了一大步，现在从头开始分析下，递推公式应该是什么？下面以以”()(())”为例。
